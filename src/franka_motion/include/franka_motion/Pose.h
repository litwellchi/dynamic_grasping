// Copyright (c) 2020 Marco Boneberger
// Licensed under the EUPL-1.2-or-later
/**
 * @file Pose.h
 * @brief Structs for Pose consisting of Position and Orientation
 * @authors Marco Boneberger
 */

#ifndef LIBORL_POSE_H
#define LIBORL_POSE_H

#include <memory>
#include <eigen3/Eigen/Eigen>
#include <eigen3/Eigen/Geometry>

namespace orl {

    /**
     * A Eigen::Vector3d which represents a Position
     */
    typedef Eigen::Vector3d Position;

    /**
     * 3D Orientation represented as Quaternion
     */
    struct Orientation {
        Orientation();

        Eigen::Quaterniond quaternion;

        /**
         * sets orientation from quaternion
         * @param quaternion
         */
        Orientation(const Eigen::Quaterniond &quaternion);

        /**
         * sets orientation with roll, pitch, yaw values
         * @param roll in radian
         * @param pitch in radian
         * @param yaw in radian
         */
        Orientation(double roll, double pitch, double yaw);

        /**
         * multiplies two orientations as Quaternion
         * @param b right hand side
         * @return a * b
         */
        Orientation operator*(const Orientation &b) const;

        /**
         * Calculates the inverse Quaternion
         * @return  inverse Quaternion as Orientation
         */
        Orientation inverse() const;

        /**
         * gives a String representation of the roll, pitch and yaw values
         * @return
         */
        std::string toString() const;

        /**
         * calculates roll pitch yaw of the Quaternion
         * @param[out] rol in radian
         * @param[out] pitch in radian
         * @param[out] yaw in radian
         */
        void get_RPY(double &roll, double &pitch, double &yaw) const;

        /**
         * sets the quaternion to a Roll-Pitch-Yaw rotation
         * @param r roll in radian
         * @param p pitch in radian
         * @param y yay in radian
         */
        void set_RPY(double r, double p, double y);

        /**
         * Rotate around a Quaternion which is generated by roll-pitch-yaw values
         * @param r roll angle in radian
         * @param p pitch angle in radian
         * @param y yaw angle in radian
         */
        void add_RPY(double r, double p, double y);
    };

    /***
     * Pose 6D Space (3D Position + 3D Orientation)
     */
    struct Pose {

        Eigen::Affine3d pose;

        /**
        * Empty Pose Constructor. Generates a Pose
        */
        Pose();

        /**
         * Create a Pose with Position and Orientation
         * @param p Position
         * @param o Orientation
         */
        Pose(const Position &p, const Orientation &o);

        /**
         * Creates Pose with Eigen::Vector3D and Quaternion
         * @param p Eigen::Vector3D Pose
         * @param o Quaternion Orientation
         */
        Pose(const Eigen::Vector3d &p, const Eigen::Quaterniond &o);

        /**
         * Initializes Pose from 4x4 homogenous matrix
         * @param mat 4x4 homogenous matrix represented as a 16 element array by concatenation of the columns of the matrix
         */
        Pose(std::array<double, 16> mat);

        /**
         * Creates a Pose from an Eigen Affine 3D
         * @param pose the pose to be used
         */
        Pose(const Eigen::Affine3d &pose);

        /**
         * Returns the translational part of the pose
         * @return Translational part of the pose
         */
        Position getPosition() const;

        /**
         * set the translational part of a pose. this does not affect the rotational part
         * @param position desired position
         */
        void setPosition(const Position &position);

        /**
         * Gets the quaternion of the pose represented as our custom orientation Struct
         * @return
         */
        Orientation getOrientation() const;

        /**
         * sets the orientational part of the pose. This does not affect the translational part of the pose. so it is no rotation.
         * see \ref multiplication to perform a rotation
         * @param orientation
         */
        void setOrientation(const Orientation &orientation);


        /**
         * returns the translational part of the transformation. It is similar to the getPosition function
         * @return
         */
        Eigen::Vector3d translation() const;

        /**
         * returns the rotational part of the pose as a matrix
         * @return 3x3 rotation matrix
         */
        Eigen::Affine3d::LinearMatrixType rotation() const;

        /**
         * returns the rotational part of the pose as quaternion
         * @return
         */
        Eigen::Quaterniond quaternion() const;

        /**
         * Performs multiplication of Poses as  homogenous matrix multiplication
         * @param pose_b an other
         * @return  the result of the multiplication
         */
        Pose operator*(const Pose &pose_b) const;

        /**
         * Performs multiplication of Poses as  homogenous matrix multiplication
         * @param affine
         * @return he result of the multiplication
         */
        Pose operator*(const Eigen::Affine3d &affine) const {
            return {pose * affine};
        };

        /**
         * performs multiplication of Poses as  homogenous matrix multiplication
         * @param lhs left hand side as Affine3d
         * @param rhs right hand side as Affine3d
         * @return
         */
        friend Pose operator*(const Eigen::Affine3d &lhs, const Pose &rhs) {
            return {lhs * rhs.pose};
        };

        /**
         * sets the translational part of the matrix
         * @param x x-coordinate in meter
         * @param y y-coordinate in meter
         * @param z z-coordinate in meter
         */
        void set_position(double x, double y, double z);

        /**
         * adds offset to the current position
         * @param x x-offset in meter
         * @param y y-offset in meter
         * @param z z-offset in meter
         */
        void add_position(double x, double y, double z);

        /**
         * Sets Pose from from 4x4 homogenous matrix
         * @param mat 4x4 homogenous matrix represented as a 16 element array by concatenation of the columns of the matrix
         */
        void set(std::array<double, 16> mat);

        /**
         * Overrides << for print out a pose
         * @param os Stream
         * @return Output Stream
         */
        std::ostream &operator<<(std::ostream &os) const;

        /**
         * converts pose to a double array;
         * @return 4x4 homogenous matrix represented as a 16 element array by concatenation of the columns of the matrix
         */
        std::array<double, 16> to_matrix() const;

        /**
         * Interpolates the Pose to a destination Pose
         * @param dest_pose goal Pose
         * @param progress value of [0-1] where 0 is the start pose and 1 is the end Pose
         * @return interpolated Pose
         */
        Pose interpolate(const Pose &dest_pose, double progress) const;

        /**
         * Converts a Pose to a String
         * @return Pose as String
         */
        std::string toString() const;

        /**
         * gets roll, pitch and yaw angles of the pose
         * @param[out] roll roll angle in radian
         * @param[out] pitch pitch angle in radian
         * @param[out] yaw yaw angle in radian
         */
        void get_RPY(double &roll, double &pitch, double &yaw) const;

        /**
         * sets roll, pitch yaw angles
         * @param r roll angle in radian
         * @param p pitch angle in radian
         * @param y yaw angle in radian
         */
        void set_RPY(double r, double p, double y);

        /**
         * Rotate  around a Quaternion which is generated by roll-pitch-yaw values
         * @param r roll angle in radian
         * @param p pitch angle in radian
         * @param y yaw angle in radian
         */
        void add_RPY(double r, double p, double y);

    };
}
#endif //LIBORL_POSE_H
